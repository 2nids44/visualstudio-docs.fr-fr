---
title: "Avertissements d’utilisation | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "vs-devops-test"
  - "vs-ide-general"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vs.codeanalysis.usagerules"
helpviewer_keywords: 
  - "avertissements, utilisation"
  - "avertissements liés à l’analyse du code managé, avertissements d’utilisation"
  - "avertissements liés à l’utilisation"
ms.assetid: fe7dc2a3-289d-4bf7-a1e4-0947a81287c4
caps.latest.revision: 24
author: "stevehoag"
ms.author: "shoag"
manager: "wpickett"
caps.handback.revision: 24
---
# Avertissements d’utilisation
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

Les avertissements d'utilisation prennent en charge une utilisation appropriée du .NET Framework.  
  
## Dans cette section  
  
|Règle|Description|  
|-----------|-----------------|  
|[CA1801 : Passez en revue les paramètres inutilisés](../Topic/CA1801:%20Review%20unused%20parameters.md)|Une signature de méthode inclut un paramètre qui n'est pas utilisé dans le corps de la méthode.|  
|[CA1806 : Ne pas ignorer les résultats de méthode](../code-quality/ca1806-do-not-ignore-method-results.md)|Un nouvel objet est créé mais jamais utilisé ; ou une méthode qui crée et retourne une nouvelle chaîne est appelée et la nouvelle chaîne n'est jamais utilisée ; ou une méthode COM ou P\/Invoke retourne un code HRESULT ou d'erreur qui n'est jamais utilisé.|  
|[CA1816 : Appeler GC.SuppressFinalize correctement](../code-quality/ca1816-call-gc-suppressfinalize-correctly.md)|Une méthode qui est une implémentation de Dispose n'appelle pas GC.SuppressFinalize ; ou une méthode qui n'est pas une implémentation de Dispose appelle GC.SuppressFinalize ; ou une méthode appelle GC.SuppressFinalize et passe un élément autre que celui\-ci \(Me en Visual Basic\).|  
|[CA2200 : Levez à nouveau une exception pour conserver les détails de la pile](../code-quality/ca2200-rethrow-to-preserve-stack-details.md)|Une exception est à nouveau levée et est spécifiée explicitement dans l'instruction throw.  Si une exception est à nouveau levée par sa spécification dans l'instruction throw, la liste des appels de méthode présents entre la méthode d'origine qui a levé l'exception et la méthode actuelle est perdue.|  
|[CA2201 : Ne levez pas des types d'exceptions réservés](../code-quality/ca2201-do-not-raise-reserved-exception-types.md)|Cela rend l'erreur d'origine difficile à détecter et à déboguer.|  
|[CA2202 : Ne pas supprimer des objets plusieurs fois](../code-quality/ca2202-do-not-dispose-objects-multiple-times.md)|Une implémentation de méthode contient des chemins d'accès de code qui peuvent provoquer des appels multiples à System.IDisposable.Dispose ou un Dispose équivalent \(par exemple, une méthode Close\(\) sur certains types\) sur le même objet.|  
|[CA2204 : Les littéraux doivent être correctement orthographiés](../code-quality/ca2204-literals-should-be-spelled-correctly.md)|Une chaîne littéral dans un corps de méthode contient un ou plusieurs mots qui ne sont pas reconnus par la bibliothèque de vérificateur d'orthographe Microsoft.|  
|[CA2205 : Utilisez des équivalents managés de l'API Win32](../code-quality/ca2205-use-managed-equivalents-of-win32-api.md)|Une méthode d'appel de code est définie et une méthode dotée de la fonctionnalité équivalente existe dans la bibliothèque de classes .NET Framework.|  
|[CA2207 : Initialisez les champs statiques des types valeur en ligne](../code-quality/ca2207-initialize-value-type-static-fields-inline.md)|Un type valeur déclare un constructeur statique explicite.  Pour corriger une violation de cette règle, initialisez toutes les données statiques lorsqu'elles sont déclarées et supprimez le constructeur statique.|  
|[CA2208 : Instanciez les exceptions d'argument comme il se doit](../code-quality/ca2208-instantiate-argument-exceptions-correctly.md)|Un appel est passé au constructeur par défaut \(sans paramètre\) d'un type d'exception qui est ou dérive d'ArgumentException, ou un argument string incorrect est passé à un constructeur paramétrable d'un type d'exception qui est ou dérive d'ArgumentException.|  
|[CA2211 : Les champs non constants ne doivent pas être visibles](../code-quality/ca2211-non-constant-fields-should-not-be-visible.md)|Les champs statiques qui ne sont ni constants ni en lecture seule ne sont pas thread\-safe.  L'accès à un tel champ doit être scrupuleusement contrôlé et requiert des techniques de programmation évoluées pour synchroniser l'accès à l'objet de classe.|  
|[CA2212 : Ne marquez pas les composants pris en charge avec WebMethod](../code-quality/ca2212-do-not-mark-serviced-components-with-webmethod.md)|Une méthode dans un type qui hérite de System.EnterpriseServices.ServicedComponent est marquée avec System.Web.Services.WebMethodAttribute.  Sachant que WebMethodAttribute et une méthode ServicedComponent ont des comportements incompatibles et des exigences en matière de contexte et de flux de transactions, le comportement de la méthode est incorrect dans certains scénarios.|  
|[CA2213 : Les champs pouvant être supprimés doivent l'être](../code-quality/ca2213-disposable-fields-should-be-disposed.md)|Un type qui implémente System.IDisposable déclare des champs de types qui implémentent également IDisposable.  La méthode Dispose du champ n'est pas appelée par la méthode Dispose du type déclarant.|  
|[CA2214 : N'appelez pas de méthodes substituables dans les constructeurs](../Topic/CA2214:%20Do%20not%20call%20overridable%20methods%20in%20constructors.md)|Lorsqu'un constructeur appelle une méthode virtuelle, il est possible que le constructeur de l'instance qui appelle la méthode n'ait pas été exécuté.|  
|[CA2215 : Les méthodes Dispose doivent appeler la fonction Dispose de la classe de base](../code-quality/ca2215-dispose-methods-should-call-base-class-dispose.md)|Si un type hérite d'un type pouvant être supprimé, il doit appeler la méthode Dispose du type de base issu de sa propre méthode Dispose.|  
|[CA2216 : Les types pouvant être supprimés doivent déclarer un finaliseur](../code-quality/ca2216-disposable-types-should-declare-finalizer.md)|Un type qui implémente System.IDisposable et présente des champs qui laissent entendre l'utilisation de ressources non managées n'implémente pas de finaliseur conforme à la description de Object.Finalize.|  
|[CA2217 : Ne pas marquer les enums avec FlagsAttribute](../code-quality/ca2217-do-not-mark-enums-with-flagsattribute.md)|Une énumération extérieurement visible est marquée par FlagsAttribute et possède une ou plusieurs valeurs qui ne sont pas des puissances de deux ou une combinaison des autres valeurs définies dans l'énumération.|  
|[CA2218 : Remplacez GetHashCode au moment de remplacer Equals](../code-quality/ca2218-override-gethashcode-on-overriding-equals.md)|GetHashCode retourne une valeur fondée sur l'instance actuelle adaptée aux algorithmes de hachage et aux structures de données telles qu'une table de hachage.  Deux objets de même type et égaux doivent retourner le même code de hachage.|  
|[CA2219 : Ne pas lever d'exceptions dans les clauses d'exception](../Topic/CA2219:%20Do%20not%20raise%20exceptions%20in%20exception%20clauses.md)|Lorsqu'une exception est levée dans une clause finally ou fault, la nouvelle exception masque l'exception active.  Lorsqu'une exception est levée dans une clause filter, le runtime l'intercepte en silence.  Cela rend l'erreur d'origine difficile à détecter et à déboguer.|  
|[CA2220 : Les finaliseurs doivent appeler le finaliseur de leur classe de base](../code-quality/ca2220-finalizers-should-call-base-class-finalizer.md)|La finalisation doit être propagée par le biais de la hiérarchie d'héritage.  Pour garantir ce procédé, les types doivent appeler leur méthode Finalize de classe de base à partir de leur propre méthode Finalize.|  
|[CA2221 : Les finaliseurs doivent être protégés](../code-quality/ca2221-finalizers-should-be-protected.md)|Les finaliseurs doivent utiliser le modificateur d'accès family.|  
|[CA2222 : Ne réduisez pas la visibilité des membres hérités](../code-quality/ca2222-do-not-decrease-inherited-member-visibility.md)|Vous ne devez pas modifier le modificateur d'accès destiné aux membres hérités.  La modification d'un membre hérité au profit d'un état privé n'empêche pas les appelants d'accéder à l'implémentation de classe de base de la méthode.|  
|[CA2223 : Les membres ne doivent pas différer uniquement par leur type de retour](../Topic/CA2223:%20Members%20should%20differ%20by%20more%20than%20return%20type.md)|Bien que le Common Language Runtime autorise l'utilisation de types de retour pour différencier des membres autrement identiques, cette fonctionnalité ne figure pas dans la Common Language Specification, et n'est pas une fonctionnalité courante des langages de programmation .NET.|  
|[CA2224 : Remplacez Equals au moment de surcharger l'opérateur égal](../code-quality/ca2224-override-equals-on-overloading-operator-equals.md)|Un type public implémente l'opérateur d'égalité, mais ne se substitue pas à Object.Equals.|  
|[CA2225 : Les surcharges d'opérateur offrent d'autres méthodes nommées](../Topic/CA2225:%20Operator%20overloads%20have%20named%20alternates.md)|Une surcharge d'opérateur a été détectée, et la méthode de substitution nommée attendue n'a pas été trouvée.  Le membre de substitution nommé donne accès aux mêmes fonctionnalités que l'opérateur. Il est fourni aux développeurs qui programment dans les langages qui ne prennent pas en charge les opérateurs surchargés.|  
|[CA2226 : Les opérateurs doivent contenir des surcharges symétriques](../code-quality/ca2226-operators-should-have-symmetrical-overloads.md)|Un type implémente l'opérateur d'égalité ou d'inégalité et n'implémente pas l'opérateur opposé.|  
|[CA2227 : Les propriétés de collection doivent être en lecture seule](../code-quality/ca2227-collection-properties-should-be-read-only.md)|Une propriété de collection accessible en écriture permet à un utilisateur de remplacer la collection par une collection différente.  Une propriété en lecture seule empêche le remplacement de la collection, mais permet quand même aux membres individuels d'être définis.|  
|[CA2228 : Ne distribuez pas des formats de ressources non commercialisés](../Topic/CA2228:%20Do%20not%20ship%20unreleased%20resource%20formats.md)|Les fichiers de ressources construits au moyen de versions préliminaires de .NET Framework  peuvent ne pas être utilisables par les versions prises en charge de .NET Framework.|  
|[CA2229 : Implémentez des constructeurs de sérialisation](../code-quality/ca2229-implement-serialization-constructors.md)|Pour corriger une violation de cette règle, implémentez le constructeur de sérialisation.  Dans le cas d'une classe sealed, rendez le constructeur privé ; sinon, attribuez\-lui l'état protégé.|  
|[CA2230 : Utilisez le mot clé params pour les arguments de variables](../code-quality/ca2230-use-params-for-variable-arguments.md)|Un type public ou protégé contient une méthode publique ou protégée qui utilise la convention d'appel VarArgs au lieu du mot clé params.|  
|[CA2231 : Surchargez l'opérateur égal \(equals\) en remplaçant ValueType.Equals](../code-quality/ca2231-overload-operator-equals-on-overriding-valuetype-equals.md)|Un type valeur se substitue à Object.Equals mais n'implémente pas l'opérateur d'égalité.|  
|[CA2232 : Marquez les points d'entrée Windows Forms avec STAThread](../code-quality/ca2232-mark-windows-forms-entry-points-with-stathread.md)|STAThreadAttribute indique que le modèle de thread COM pour l'application est un thread cloisonné \(STA, Single\-Threaded Apartment\).  Cet attribut doit être présent au point d'entrée de toute application qui utilise des Windows Forms ; s'il est omis, les composants Windows peuvent ne pas fonctionner correctement.|  
|[CA2233 : Les opérations ne doivent pas déborder](../code-quality/ca2233-operations-should-not-overflow.md)|Les opérations arithmétiques ne doivent pas être exécutées sans valider au préalable les opérandes afin de s'assurer que le résultat de l'opération ne se trouve pas hors de la plage des valeurs possibles pour les types de données impliqués.|  
|[CA2234 : Passez des objets System.Uri à la place de chaînes](../Topic/CA2234:%20Pass%20System.Uri%20objects%20instead%20of%20strings.md)|Un appel est passé à une méthode qui a un paramètre de chaîne dont le nom contient « uri », « URI », « urn », « URN », « url » ou « URL ».  Le type déclarant de la méthode contient une surcharge de méthode correspondante qui a un paramètre System.Uri.|  
|[CA2235 : Marquez tous les champs non sérialisés](../code-quality/ca2235-mark-all-non-serializable-fields.md)|Un champ d'instance d'un type non sérialisable est déclaré dans un type sérialisable.|  
|[CA2236 : Appelez les méthodes de la classe de base sur les types ISerializable](../code-quality/ca2236-call-base-class-methods-on-iserializable-types.md)|Pour corriger une violation de cette règle, appelez la méthode GetObjectData ou le constructeur de sérialisation du type de base issu du constructeur ou de la méthode du type dérivé correspondant.|  
|[CA2237 : Marquer les types ISerializable avec SerializableAttribute](../code-quality/ca2237-mark-iserializable-types-with-serializableattribute.md)|Pour être reconnus par le Common Language Runtime comme sérialisables, les types doivent être marqués avec l'attribut SerializableAttribute même s'ils utilisent une routine de sérialisation personnalisée par le biais de l'implémentation de l'interface ISerializable.|  
|[CA2238 : Implémentez les méthodes de sérialisation comme il se doit](../code-quality/ca2238-implement-serialization-methods-correctly.md)|Une méthode qui gère un événement de sérialisation n'a pas la signature, le type de retour ou la visibilité appropriée.|  
|[CA2239 : Spécifiez des méthodes de désérialisation pour les champs facultatifs](../code-quality/ca2239-provide-deserialization-methods-for-optional-fields.md)|Un type présente un champ marqué avec l'attribut System.Runtime.Serialization.OptionalFieldAttribute et ne fournit aucune méthode de gestion des événements de désérialisation.|  
|[CA2240 : Implémentez ISerializable comme il se doit](../Topic/CA2240:%20Implement%20ISerializable%20correctly.md)|Pour corriger une violation de cette règle, rendez la méthode GetObjectData visible et substituable, et assurez\-vous que tous les champs d'instance sont intégrés au processus de sérialisation ou sont marqués explicitement avec l'attribut NonSerializedAttribute.|  
|[CA2241 : Fournissez des arguments corrects aux méthodes de mise en forme](../code-quality/ca2241-provide-correct-arguments-to-formatting-methods.md)|L'argument format passé à System.String.Format ne contient aucun élément de format qui corresponde à chaque argument d'objet, ou vice versa.|  
|[CA2242 : Effectuez correctement des tests NaN](../code-quality/ca2242-test-for-nan-correctly.md)|Cette expression teste une valeur par rapport à Single.Nan ou Double.Nan.  Utilisez Single.IsNan\(Single\) ou Double.IsNan\(Double\) pour tester la valeur.|  
|[CA2243 : Les littéraux de chaîne d'attribut doivent être correctement analysés](../code-quality/ca2243-attribute-string-literals-should-parse-correctly.md)|Le paramètre de littéral de chaîne d'un attribut n'effectue pas une analyse correcte pour une URL, un GUID ou une version.|