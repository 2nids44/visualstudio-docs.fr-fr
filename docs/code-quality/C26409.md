---
title: C26409 | Documents Microsoft
ms.custom: ''
ms.date: 07/21/2017
ms.technology:
- vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- C26409
helpviewer_keywords:
- C26409
ms.assetid: a3b3a229-d566-4be3-bd28-2876ccc8dc37
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: f8337f5df235e1fd8d266c11f2644911a4db92d5
ms.sourcegitcommit: 6a9d5bd75e50947659fd6c837111a6a547884e2a
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/16/2018
---
# <a name="c26409-nonewdelete"></a>C26409 NO_NEW_DELETE
  Même si le code est propre d’appels à malloc() et free() nous suggérons toujours tenir compte des meilleures options que l’utilisation explicite des opérateurs [nouveau et supprimer](/cpp/cpp/new-and-delete-operators). Afficher plus de détails dans la description de la règle *R.11 : Évitez d’appeler de nouveau et supprimer explicitement*. La solution ultime consiste à démarrer à l’aide de pointeurs intelligents avec des méthodes de fabrique appropriée, comme [std::make_unique](/cpp/standard-library/memory-functions#make_unique).

## <a name="remarks"></a>Notes
- L’outil de vérification vous avertit lors des appels à n’importe quel type d’opérateur `new` ou `delete`: scalaire, vecteur, les versions surchargées (globale et spécifiques à la classe), ainsi que sur les versions de la sélection élective. Le dernier cas peut nécessiter des précisions sur les directives de base en termes de suggestions de correction et peut être omis dans le futur.
